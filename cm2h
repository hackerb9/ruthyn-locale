#!/bin/gawk -nf
# Charmap to 8-bit .h table for gconv module.
# Usage: ./cm2h.awk tandy-200.charmap > tandy-200.h
#
# Given a charmap(5) file, output data for a .h table usable with
# glibc's 8bit-generic.c or 8bit-gap.c.

# Input lines look like this:
# <U0192>     /xBF             MATHEMATICAL CURVED F [CODE+SHIFT+F]
# %<UDFFF>     /xed/xbf/xbf <Low Surrogate, Last>
# <U000E01EF> /xf3/xa0/x87/xaf VARIATION SELECTOR-256

# See /usr/share/i18n/charmaps/ for sample charmaps. 

# Charmap data format accepted:
# "<U%s> %s %s\n", <ucs-hex>, <encoding>, <comments>

# Not yet accepted:
# "%s...%s %s %s\n", <symbolic-name>, <symbolic-name>, <encoding>, <comments>
# "%s..%s %s %s\n", <symbolic-name>, <symbolic-name>, <encoding>, <comments>


# BUGS:

#     * This does not handle multibyte encodings. This is due to
#	relying on glibc's 8bit-generic.c (or 8bit-gap.c) to do the
#	heavy lifting.

#     *	When using gapstyle=1, many-to-one mappings are ignored.
#	This is a limitation of glibc's 8bit-gap.c code.

#     *	Charmap files can use "..." to specify a range of symbolic
#	names (e.g, `<J0101>...<J0127>` that map to sequential byte
#	encodings. This script does not handle that, yet. Nor does it
#	handle GNU's extension to use two dots for hexadecimal ranges.

#     *	Bases other than hexadecimal are not accepted. (\d255 and \77).

#     *	Charmap files can be specified using mnemonic symbolic names,
#	but this script presumes UCS code points of the form <U1234>.
#	Fixing this would require parsing the repertoiremap(5) and is
#	unlikely to be worth it..

#     * One must set gapstyle=1 to create output that is compatible
#	with 8bit-gap.c. I.e., cm2h -v gapstyle=1 tandy-200.charmap.
#	But perhaps gap support isn't needed and should be removed.
#
#	I (hackerb9) am not yet clear on the purpose of 8bit-gap.c.
#	Presumably it either saves memory or time or both. However,
#	8bit-generic has caused no noticeable problems, is more
#	straight-forward, and most importantly allows for many-to-one
#	mappings. (E.g., both UCS VERTICAL BAR and BROKEN BAR can
#	display as the same 8-bit character.).

BEGIN {
    progname = PROCINFO["argv"][2];
    IGNORECASE = 1;
    incharmap = 0;
    comment_char = "#";		# charmaps from GNU & IBM set this to "%".
    escape_char = "\\"; 	# charmaps from GNU & IBM set this to "/".
    
    # To compile with 8bit-gap.c, use `cm2h -v gapstyle=1 foo.charmap > foo.h`
    #gapstyle = 0; 		# 0: 8bit-generic.c,  1: 8bit-gap.c style.
}

$1=="<code_set_name>" { code_set_name=$2; }
$1=="<comment_char>" { comment_char=$2; }
$1=="<escape_char>" { escape_char=$2; }

# Skip lines that start with the comment character (typically %)
$1 ~ "^" comment_char { next; }

# Only process lines between "CHARMAP" and "END CHARMAP"
$1=="CHARMAP" { incharmap=1; next; }
$1=="END" && $2=="CHARMAP" { incharmap=0; next; }

incharmap==1 {
    # Read each Unicode character (in hexadecimal) and
    # the corresponding byte sequence (also in hex), and output both,
    # sorted by Unicode.
    # BUG: Does not handle mnemonic,ds symbolnames.
    # BUG: Does not handle /d for decimal input, nor / for octal.

    # Look for hex in $1 (like <U000E01EF>)
    if (! match($1, /<U([0-9A-F]+)>/, matcharray)) { next; }
    ucsidx = toupper(matcharray[1]);

    # Look for hex in $2 (like /xf3/xa0/x87/xaf -> a[1]=f3)
    patsplit($2, a, /[0-9A-F]+/);
    code = tolower(a[1]);

    if (revmap[code]=="") {
	/* Use first definition when mapping 8bit -> UCS, ignore others. */
	revmap[code] = ucsidx;
    }
    else if (gapstyle) {
	print "Warning: 8bit-gap.c cannot handle many-to-one mappings." > "/dev/stderr";
	print "\t" FILENAME ":" NR, $0 > "/dev/stderr"
	next
    }

    if (map[ucsidx]!="") {
	print "Error: UCS codes must be unique." > "/dev/stderr";
	print FILENAME ":" NR, $0 > "/dev/stderr"
	printf "<U%s> already set to %s\n:", ucsidx, map[ucsidx] > "/dev/stderr"
	ERRNO = 1; exit;			# Awk's exit still runs END {}
    }
	
    if (length(a)>1) {
	print "Error. Cannot yet handle multibyte encodings." > "/dev/stderr"
	print FILENAME ":" NR, $0 > "/dev/stderr"
	ERRNO = 1; exit;			# Awk's exit still runs END {}
	for (i in a) {map[ucsidx] = map[ucsidx] a[i] " ";}
    }

    map[ucsidx] = code;
}

ENDFILE {
    printf ("/* Generated by '%s %s' */\n", progname, FILENAME );

    /* Create views sorted by indices */
    asorti( map, sorted, "hexcompare" );
    asorti( revmap, rsorted, "hexcompare" );
    
    add_gapstyle_def();
    print_to_ucs4_table();
    if (gapstyle) print_from_idx_table();
    print_from_ucs4_table();

}

END { if (ERRNO) exit ERRNO; }

function hexcompare(i1, v1, i2, v2,   l,r) {
    /* Compares indices as hexadecimal numbers for sorting */
    l = sprintf("%d", "0x" i1);
    r = sprintf("%d", "0x" i2);
    return l-r;
}

function add_gapstyle_def() {
    # Write a one line file called charset-gapstyle.h to be used by charset.c.
    # when deciding whether to compile with 8bit-generic.c or 8bit-gap.c.
    # Uses global variable gapstyle.
    output = tolower(FILENAME);
    sub(/.charmap/, "", output);
    output = output "-gapstyle.h";

    if (gapstyle)
	print "#define GAPSTYLE 1\t\t/* Use 8bit-gap.c */"   >   output;
    else
	print "#define GAPSTYLE 0\t\t/* Use 8bit-generic.c */" > output;
}

function print_to_ucs4_table(   i) {
    print "static const uint32_t to_ucs4[256] = {"
    for (i in rsorted) {
	printf("  [0x%s] = 0x%s,\n", rsorted[i], revmap[rsorted[i]]);
    }
    print "};\n";
}

function print_from_idx_table(     i, u, first, last, ucsidx) {
    # Algorithm from glibc-2.28/iconvdata/gap.awk
    print "static const struct gap from_idx[] = {";
    for (i in sorted) {
	u = int( "0x" sorted[i] );
	if (u - last > 6) {
	    if (last) {
		printf ("  { .start = %#06x, .end = %#06x, .idx = %5d },\n",
				      first,        last,         ucsidx);
		ucsidx -= u - last - 1;
	    }
	    first = u;
	}
	last = u;
    }
    printf ("  { .start = 0x%04x, .end = 0x%04x, .idx = %5d },\n",
	    first, last, ucsidx); 
    print "};\n";
}

function print_from_ucs4_table() {
    if (!gapstyle)
	print_from_ucs4_table_generic()
    else
	print_from_ucs4_table_gap()
}	

function print_from_ucs4_table_generic(    i) {
    # Based on glibc-2.28/iconvdata/gen8bit.sh
    printf( "static const char from_ucs4[] = {\n" )
    for (i in sorted) {
	printf("  [0x%s] = 0x%s,\n", sorted[i], map[sorted[i]]);
    }	
    print "\n};\n";
}

function fmt(val) {
    # Helper function for gap style from_ucs4
    if (f++ % 8 == 0) {
	printf ("\n ");
    }
    if (val != "") printf (" '\\x%s',", val);
}

function print_from_ucs4_table_gap(    i, u, first, last) {
    # Based on glibc-2.28/iconvdata/gaptab.awk
    printf( "static const char from_ucs4[] = {" )
    for (i=1; i<=256; i++) {
	u = int( "0x" sorted[i] );
	if (u - last > 6) { first = u; }
	else {
	    for (m = last+1; m < u; m++) { fmt("00"); }
	}
	fmt( map[sorted[i]] );
	last = u;
    }
    print "\n};\n";
}

function debugarray(a,   i) {
    /* Print out all elements of an array */
    for (i in a) {
	print i, a[i];
    }
    return;
}
